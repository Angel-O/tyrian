[
{
	"uri": "http://example.org/installation/",
	"title": "Setup &amp; Configuration",
	"tags": [],
	"description": "",
	"content": "Installation Tyrian is a Scala 3 Web UI library, so please set your Scala version to 3.1.0 or higher.\n You can use Tyrian with Scala 2 thanks to cross versions and the magic of TASTy.\n Please note that both the sbt and Mill instructions below assume you intend to work with some sort of web packager/bundler, and therefore emit common js modules.\nThe examples in the Tyrian repo almost all use Parcel.js as the bundler.\nsbt Add the Scala.js plugin to your project/plugins.sbt file.\naddSbtPlugin(\u0026#34;org.scala-js\u0026#34; % \u0026#34;sbt-scalajs\u0026#34; % \u0026#34;1.8.0\u0026#34;) Enable the plugin and add the Tyrian library to your build.sbt file.\nenablePlugins(ScalaJSPlugin) libraryDependencies ++= Seq( \u0026#34;io.indigoengine\u0026#34; %%% \u0026#34;tyrian\u0026#34; % \u0026#34;0.2.2-SNAPSHOT\u0026#34; ) scalaJSUseMainModuleInitializer := true, scalaJSLinkerConfig ~= { _.withModuleKind(ModuleKind.CommonJSModule) } Optionally, you can also include the Tyrian/Indigo Bridge library if you plan to embed an Indigo game in your page:\nlibraryDependencies ++= Seq( ... \u0026#34;io.indigoengine\u0026#34; %%% \u0026#34;tyrian-indigo-bridge\u0026#34; % \u0026#34;0.2.2-SNAPSHOT\u0026#34; ) Mill Below is a complete, basic Mill build.sc file including MUnit for testing.\nimport $ivy.`com.lihaoyi::mill-contrib-bloop:$MILL_VERSION` import mill._ import mill.scalalib._ import mill.scalajslib._ import mill.scalajslib.api._ object counter extends ScalaJSModule { def scalaVersion = \u0026#34;3.1.0\u0026#34; def scalaJSVersion = \u0026#34;1.8.0\u0026#34; def ivyDeps = Agg(ivy\u0026#34;io.indigoengine::tyrian::0.2.2-SNAPSHOT\u0026#34;) override def moduleKind = T(mill.scalajslib.api.ModuleKind.CommonJSModule) override def useECMAScript2015 = T(true) // required for the tyrian/indigo bridge  object test extends Tests { def ivyDeps = Agg(ivy\u0026#34;org.scalameta::munit::0.7.29\u0026#34;) def testFramework = \u0026#34;munit.Framework\u0026#34; override def moduleKind = T(mill.scalajslib.api.ModuleKind.CommonJSModule) override def jsEnvConfig = T(JsEnvConfig.NodeJs(args = List(\u0026#34;--dns-result-order=ipv4first\u0026#34;))) override def useECMAScript2015 = T(true) } } Optionally, you can also include the Tyrian/Indigo Bridge library if you plan to embed an Indigo game in your page:\ndef ivyDeps = Agg( ivy\u0026#34;io.indigoengine::tyrian::0.2.2-SNAPSHOT\u0026#34;, ivy\u0026#34;io.indigoengine::tyrian-indigo-bridge::0.2.2-SNAPSHOT\u0026#34; ) "
},
{
	"uri": "http://example.org/architecture/",
	"title": "Architecture",
	"tags": [],
	"description": "",
	"content": "The Elm Architecture (TEA Pattern) Tyrian provides a runtime environment for executing applications designed according to the Elm architecture.\nIn essence, the state of the application is modeled by an immutable Model, events that change the state of the application are modeled by an immutable Msg type, state transitions are implemented by a (Msg, Model) =\u0026gt; Model function, and finally, a Model =\u0026gt; Html[Msg] function defines how to render the state of the application in HTML.\nTyrian vs Indigo // TODO\n"
},
{
	"uri": "http://example.org/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "Examples There are several examples in the examples folder to help get you started.\nRunning the examples To run them you will need to have yarn (or npm) installed.\nOn first run:\nyarn install \u0026hellip;and from then on:\nyarn start Then navigate to http://localhost:1234/\nThings to know about the examples The examples are useful but before you wholesale copy one to use as a starting point.\n  They refer to the underlying Tyrian sbt project, so you\u0026rsquo;ll need to add a proper library dependency.\n  They are built weirdly, because they\u0026rsquo;re designed to be built and run as a one-liner alongside the main project.\n The examples use parcel to do the heavy lifting involved with pulling the project together, which is fine, you could also use webpack or whatever you prefer. However, if you look at the \u0026ldquo;start\u0026rdquo; script, you\u0026rsquo;ll see it invokes sbt fastOptJS \u0026amp;\u0026amp; (..), which you should not do. If you run parcel and leave it running (yarn start, minus the sbt bit), and re-run fastOptJS as you would during normal development, parcel will see the file change (as it would any other resource) and reload the site for you immediately - MUCH FASTER! If you\u0026rsquo;d like to keep the current build arrangement you see in the \u0026ldquo;start\u0026rdquo; scripts, it might be nicer to switch from sbt to Mill or sbt\u0026rsquo;s thin client. They may be better suited to this build arrangement with lots of cold starts.    Reacting to User Input Here is what the standard Elm counter example looks like in Tyrian:\nimport tyrian.{Html, Tyrian} import tyrian.Html._ import org.scalajs.dom.document object Main: opaque type Model = Int def main(args: Array[String]): Unit = Tyrian.start(document.getElementById(\u0026#34;myapp\u0026#34;), init, update, view) def init: Model = 0 def update(msg: Msg, model: Model): Model = msg match case Msg.Increment =\u0026gt; model + 1 case Msg.Decrement =\u0026gt; model - 1 def view(model: Model): Html[Msg] = div()( button(onClick(Msg.Decrement))(text(\u0026#34;-\u0026#34;)), div()(text(model.toString)), button(onClick(Msg.Increment))(text(\u0026#34;+\u0026#34;)) ) enum Msg: case Increment, Decrement Dealing With Effects In the architecture presented above, the state of the application evolves with DOM events but there is no way to perform HTTP requests or register a timer. We call this kind of actions “effects”. We classify them into two groups: commands and subscriptions. Commands let you do stuff, whereas subscriptions let you register that you are interested in something. You can find more information on effects here.\nHere is what the Elm clock example looks like in Tyrian (using seconds):\nimport tyrian.{Cmd, Html, Tyrian, Sub} import tyrian.Html._ import org.scalajs.dom.document import scalajs.js import concurrent.duration.DurationInt object Clock: opaque type Model = js.Date def init: (Model, Cmd[Msg]) = (new js.Date(), Cmd.Empty) def update(msg: Msg, model: Model): (Model, Cmd[Msg]) = (msg.newTime, Cmd.Empty) def view(model: Model): Html[Msg] = { val angle = model.getSeconds() * 2 * math.Pi / 60 - math.Pi / 2 val handX = 50 + 40 * math.cos(angle) val handY = 50 + 40 * math.sin(angle) tag(\u0026#34;svg\u0026#34;)(attributes(\u0026#34;viewBox\u0026#34; -\u0026gt; \u0026#34;0, 0, 100, 100\u0026#34;, \u0026#34;width\u0026#34; -\u0026gt; \u0026#34;300px\u0026#34;))( tag(\u0026#34;circle\u0026#34;)(attributes(\u0026#34;cx\u0026#34; -\u0026gt; \u0026#34;50\u0026#34;, \u0026#34;cy\u0026#34; -\u0026gt; \u0026#34;50\u0026#34;, \u0026#34;r\u0026#34; -\u0026gt; \u0026#34;45\u0026#34;, \u0026#34;fill\u0026#34; -\u0026gt; \u0026#34;#0B79CE\u0026#34;))(), tag(\u0026#34;line\u0026#34;)( attributes( \u0026#34;x1\u0026#34; -\u0026gt; \u0026#34;50\u0026#34;, \u0026#34;y1\u0026#34; -\u0026gt; \u0026#34;50\u0026#34;, \u0026#34;x2\u0026#34; -\u0026gt; handX.toString, \u0026#34;y2\u0026#34; -\u0026gt; handY.toString, \u0026#34;stroke\u0026#34; -\u0026gt; \u0026#34;#023963\u0026#34; ) )() ) } def subscriptions(model: Model): Sub[Msg] = Sub.every(1.second, \u0026#34;clock-ticks\u0026#34;).map(Msg.apply) def main(args: Array[String]): Unit = Tyrian.start(document.getElementById(\u0026#34;myapp\u0026#34;), init, update, view, subscriptions) final case class Msg(newTime: js.Date) "
},
{
	"uri": "http://example.org/information/",
	"title": "General Information",
	"tags": [],
	"description": "",
	"content": "Discussion If you\u0026rsquo;re new to the territory, I highly recommend this thoughtful blog post by Laminar\u0026rsquo;s author, Nikita Gazarov.\nThere is a point in that post where Nikita says the following:\n (..) and having now walked the path myself I finally understood exactly what that reason was: functional reactive programming (FRP) and virtual DOM don\u0026rsquo;t mix!\nVirtual DOM and FRP solve the exact same problem – efficiently keeping the rendered DOM in sync with application state – but they approach it from entirely opposite directions (..)\n \u0026hellip;and that is entirely correct in my opinion. It\u0026rsquo;s an important fork in the road. One direction takes you to FRP and Laminar, the other to Virtual DOM like Tyrian and Elm. Both are equally valid choices with quite subtle trade-offs.\nBroadly the argument for FRP is speed, as updates are minimal and precise. The argument for Virtual DOM is that it\u0026rsquo;s easier to test and reason about.\nHowever, You don\u0026rsquo;t have to look hard to find counter arguments to both positions: Elm is blazing fast, and Laminar has solved the classic diamond problem. \u0026hellip;but that\u0026rsquo;s the general argument.\nIn the end, it\u0026rsquo;s mostly personal preference.\nProvenance, and a note of thanks Tyrian was originally a fork of Scalm by Julien Richard-Foy.\nScalm was the Scala.js library I\u0026rsquo;d been looking for but found too late, and it\u0026rsquo;s great fun! In my opinion it was simply ahead of its time, and alas the original authors and contributors had moved on to pastures new long before it was brought to my attention.\nI decided to fork it and re-release it under a new name, partly because I wanted to take it in my own direction without corrupting the original work, and partly \u0026hellip;because I just wasn\u0026rsquo;t sure how to pronounce Scalm! (I did ask!)\nScalm/Tyrian and Indigo (which I also look after) are kindred spirits, in that they both follow the TEA pattern (The Elm Architecture), which is the only frontend architecture pattern I\u0026rsquo;m interested in these days.\nI hope to use Tyrian to complement Indigo, and so have brought it in under the same organisation.\nTyrian is Scalm with the cobwebs blown off. All it\u0026rsquo;s libraries are up to date, I\u0026rsquo;ve started expanding the API, and it will only ever be released against Scala 3.\nWith huge thanks to the original developers,\nDave, 5th June 2021\n\u0026ldquo;Tyrian\u0026rdquo; Purple  \u0026ldquo;It took tens of thousands of desiccated hypobranchial glands, wrenched from the calcified coils of spiny murex sea snails before being dried and boiled, to colour even a single small swatch of fabric, whose fibres, long after staining, retained the stench of the invertebrate\u0026rsquo;s marine excretions. Unlike other textile colours, whose lustre faded rapidly, Tyrian purple \u0026hellip; only intensified with weathering and wear – a miraculous quality that commanded an exorbitant price, exceeding the pigment\u0026rsquo;s weight in precious metals.\u0026rdquo; ~ BBC\n So it\u0026rsquo;s a purple dye that smells of where it came from and gets richer over time with use. Perfect.\n"
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/",
	"title": "Tyrian",
	"tags": [],
	"description": "",
	"content": "An Elm-inspired Scala UI library for Scala 3.\nMotivation TODO\nWhat should I use Tyrian for? TODO\nWhat should I avoid using Tyrian for? TODO\n"
}]