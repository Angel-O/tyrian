[
{
	"uri": "https://purplekingdomgames.github.io/tyrian/installation/",
	"title": "Setup &amp; Configuration",
	"tags": [],
	"description": "",
	"content": "Installation Tyrian is a Scala 3 Web UI library, so please set your Scala version to 3.1.0 or higher.\n You can use Tyrian with Scala 2 thanks to cross versions and the magic of TASTy.\n Please note that both the sbt and Mill instructions below assume you intend to work with some sort of web packager/bundler, and therefore emit common js modules.\nThe examples in the Tyrian repo almost all use Parcel.js as the bundler.\nsbt Add the Scala.js plugin to your project/plugins.sbt file.\naddSbtPlugin(\u0026#34;org.scala-js\u0026#34; % \u0026#34;sbt-scalajs\u0026#34; % \u0026#34;1.8.0\u0026#34;) Enable the plugin and add the Tyrian library to your build.sbt file.\nenablePlugins(ScalaJSPlugin) libraryDependencies ++= Seq( \u0026#34;io.indigoengine\u0026#34; %%% \u0026#34;tyrian\u0026#34; % \u0026#34;0.2.2-SNAPSHOT\u0026#34; ) scalaJSUseMainModuleInitializer := true, scalaJSLinkerConfig ~= { _.withModuleKind(ModuleKind.CommonJSModule) } Optionally, you can also include the Tyrian/Indigo Bridge library if you plan to embed an Indigo game in your page:\nlibraryDependencies ++= Seq( ... \u0026#34;io.indigoengine\u0026#34; %%% \u0026#34;tyrian-indigo-bridge\u0026#34; % \u0026#34;0.2.2-SNAPSHOT\u0026#34; ) Mill Below is a complete, basic Mill build.sc file including MUnit for testing.\nimport $ivy.`com.lihaoyi::mill-contrib-bloop:$MILL_VERSION` import mill._ import mill.scalalib._ import mill.scalajslib._ import mill.scalajslib.api._ object counter extends ScalaJSModule { def scalaVersion = \u0026#34;3.1.0\u0026#34; def scalaJSVersion = \u0026#34;1.8.0\u0026#34; def ivyDeps = Agg(ivy\u0026#34;io.indigoengine::tyrian::0.2.2-SNAPSHOT\u0026#34;) override def moduleKind = T(mill.scalajslib.api.ModuleKind.CommonJSModule) override def useECMAScript2015 = T(true) // required for the tyrian/indigo bridge  object test extends Tests { def ivyDeps = Agg(ivy\u0026#34;org.scalameta::munit::0.7.29\u0026#34;) def testFramework = \u0026#34;munit.Framework\u0026#34; override def moduleKind = T(mill.scalajslib.api.ModuleKind.CommonJSModule) override def jsEnvConfig = T(JsEnvConfig.NodeJs(args = List(\u0026#34;--dns-result-order=ipv4first\u0026#34;))) override def useECMAScript2015 = T(true) } } Optionally, you can also include the Tyrian/Indigo Bridge library if you plan to embed an Indigo game in your page:\ndef ivyDeps = Agg( ivy\u0026#34;io.indigoengine::tyrian::0.2.2-SNAPSHOT\u0026#34;, ivy\u0026#34;io.indigoengine::tyrian-indigo-bridge::0.2.2-SNAPSHOT\u0026#34; ) "
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/architecture/",
	"title": "Architecture &amp; Patterns",
	"tags": [],
	"description": "",
	"content": "The Elm Architecture Tyrian provides a runtime environment for executing applications designed according to the Elm architecture.\nElm is the name of a language and an ecosystem, but it\u0026rsquo;s architecture has become more widely known as the \u0026lsquo;TEA Pattern\u0026rsquo; ((T)he (E)lm (A)rchitecture) and has influenced many GUI/UI libraries and implementations beyond the world of functional programming.\nThe TEA pattern The TEA Pattern is about:\n Immutable data. Pure functions. Uni-directional data flow. Strictly ordered events and updates.  This gives you a system that is very easy it reason about, since the data cannot/is unlikely to be subject to hard-to-test race conditions or side effects, and everything happens in a predictable order.\nThe purity of the system, the way that the state is held apart from the processing and rendering functions, also allows for easy testing without the need for complex mocking.\nIn essence, the state of the application is modeled by an immutable Model, events that change the state of the application are modeled by an immutable Msg type, state transitions are implemented by a (Msg, Model) =\u0026gt; Model function, and finally, a Model =\u0026gt; Html[Msg] function defines how to render the state of the application in HTML.\nTyrian vs Elm Elm is, as you would expect, a far richer offering that Tyrian is or in all likelihood, ever will be. There are a lot more people working on it and with it, and it\u0026rsquo;s been around a lot longer.\nHaving said that, while Elm\u0026rsquo;s architecture has taken on a life of it\u0026rsquo;s own and influenced the state of the art of functional (and even non-FP!) UI programming, Elm itself is still quite niche.\nPeople tend to love Elm, or hate it. A lot of that reaction can be attributed to the fact that Elm is a very opinionated language, and you\u0026rsquo;re either into that ..or you\u0026rsquo;re not.\nWhat Elm\u0026rsquo;s opinionated stance buys you is an ecosystem where if your code compiles, it works! And that is an amazing thing! In the cost/benefit analysis: The benefit is an incredibly robust web development experience, at the cost of literally not being able to do anything that is not permitted (because it would break the robustness guarantees of the ecosystem).\nTyrian takes the glorious essence of Elm\u0026rsquo;s architecture, but removes almost all of the opinions \u0026hellip;and with it of course, almost all of the safety nets!\n Want to break up your code into lots of files and classes? Carry on. Want to use refined types? Ok then. Want to use Typeclasses? No problem. Want to bring in a heavyweight FP library? Sure thing. Want to talk to JavaScript directly over an FFI? Go nuts. Want to do a non-exhaustive match? I mean, you can but\u0026hellip; Want to throw a massive exception? \u0026hellip;erm\u0026hellip;  Be safe out there folks! 😀\nTyrian vs Indigo Tyrian and Indigo are siblings and both follow an interpretation of the TEA Pattern, but they grew up at different times under different influences, and so are not the same.\nTyrian is designed in the same image as Elm, and for the same purpose: Building rich web apps. Indigo however is a game engine. They do have a lot of things in common:\n The APIs are all pure functions The state is immutable The data follows a uni-directional path Events/Messages are strictly ordered \u0026hellip;even the names and signatures of the API functions are similar  \u0026hellip;and so on.\nBut if you consider the life of a GUI app versus a game - in general - user interfaces don\u0026rsquo;t do anything except as a reaction to user input. Yes, there are exceptions, you can do animations, people do use Elm to make games, etc. But as a broad brush principle, most of the time your word processor or photo editing app are doing nothing, unless you are doing something with them. Hammering keys and painting with you mouse.\nGames on the other hand are normally doing things all the time. Even if the player isn\u0026rsquo;t doing anything! There will be background animations, particle effects will be firing, non-player characters will be walking around, your character will get bored and start impatiently tapping their foot.\nTwo of the main ways this difference visibly manifests itself are:\n Cmd vs Outcome The nature of your Model instance  Cmd vs Outcome The update function in Tyrian returns a (Model, Cmd) where the command is a lazily evaluated task - perhaps an HTTP call or some other side effect. Whereas in Indigo you return an Outcome, but an outcome does not allow you to directly describe actions that would need evaluation, it only captures updated values and events. If you want to make an HTTP call, there\u0026rsquo;s an event for that.\nIn Tyrian we expect that you\u0026rsquo;ll be doing a lot of out-of-band work like calling web services and interacting with JS over and FFI, in Indigo we assume you mostly won\u0026rsquo;t be.\nThis has the interesting side effect that Tyrian\u0026rsquo;s update functions are referentially transparent, but Indigo\u0026rsquo;s are both referentially transparent and declarative. The former allows you to do more practical things, the latter is lighter and easier to test, but less clean if you do need to, say, call down to JavaScript.\nThe nature of your Model What is in your model?\nIn a GUI app, your model is probably quite close to representing the things that will be displayed. Perhaps it holds the current state of a quiz or survey for example, or the items in a todo list.\nIn a game, the model (in Indigo at least) tends to be much more abstract and divorced from any presentation concerns. So much so that Indigo has an extra model called a ViewModel that behaves more like a model in Tyrian.\nAs an example: Consider the score counter on a pinball machine. What makes these fun is that they do not simply show your score, they rapidly roll through the numbers always trying to keep up with your score!\nWe have two things we have to know to draw this effect:\n The real score the player has achieved. The score currently being shown.  In Tyrian, both of these values would be held in the Model. In Indigo, the real score (1) would be held in the Model as it\u0026rsquo;s a factual piece of data, while the currently displayed score would live in the ViewModel since it\u0026rsquo;s purely there for presentation purposes.\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "Examples There are several examples in the examples folder to help get you started.\nRunning the examples To run them you will need to have yarn (or npm) installed.\nOn first run:\nyarn install \u0026hellip;and from then on:\nyarn start Then navigate to http://localhost:1234/\nThings to know about the examples The examples are useful but before you wholesale copy one to use as a starting point.\n  They refer to the underlying Tyrian sbt project, so you\u0026rsquo;ll need to add a proper library dependency.\n  They are built weirdly, because they\u0026rsquo;re designed to be built and run as a one-liner alongside the main project.\n The examples use parcel to do the heavy lifting involved with pulling the project together, which is fine, you could also use webpack or whatever you prefer. However, if you look at the \u0026ldquo;start\u0026rdquo; script, you\u0026rsquo;ll see it invokes sbt fastOptJS \u0026amp;\u0026amp; (..), which you should not do. If you run parcel and leave it running (yarn start, minus the sbt bit), and re-run fastOptJS as you would during normal development, parcel will see the file change (as it would any other resource) and reload the site for you immediately - MUCH FASTER! If you\u0026rsquo;d like to keep the current build arrangement you see in the \u0026ldquo;start\u0026rdquo; scripts, it might be nicer to switch from sbt to Mill or sbt\u0026rsquo;s thin client. They may be better suited to this build arrangement with lots of cold starts.    Reacting to User Input Here is what the standard Elm counter example looks like in Tyrian:\nimport tyrian.{Html, Tyrian} import tyrian.Html._ import org.scalajs.dom.document object Main: opaque type Model = Int def main(args: Array[String]): Unit = Tyrian.start(document.getElementById(\u0026#34;myapp\u0026#34;), init, update, view) def init: Model = 0 def update(msg: Msg, model: Model): Model = msg match case Msg.Increment =\u0026gt; model + 1 case Msg.Decrement =\u0026gt; model - 1 def view(model: Model): Html[Msg] = div()( button(onClick(Msg.Decrement))(text(\u0026#34;-\u0026#34;)), div()(text(model.toString)), button(onClick(Msg.Increment))(text(\u0026#34;+\u0026#34;)) ) enum Msg: case Increment, Decrement Dealing With Effects In the architecture presented above, the state of the application evolves with DOM events but there is no way to perform HTTP requests or register a timer. We call this kind of actions “effects”. We classify them into two groups: commands and subscriptions. Commands let you do stuff, whereas subscriptions let you register that you are interested in something. You can find more information on effects here.\nHere is what the Elm clock example looks like in Tyrian (using seconds):\nimport tyrian.{Cmd, Html, Tyrian, Sub} import tyrian.Html._ import org.scalajs.dom.document import scalajs.js import concurrent.duration.DurationInt object Clock: opaque type Model = js.Date def init: (Model, Cmd[Msg]) = (new js.Date(), Cmd.Empty) def update(msg: Msg, model: Model): (Model, Cmd[Msg]) = (msg.newTime, Cmd.Empty) def view(model: Model): Html[Msg] = { val angle = model.getSeconds() * 2 * math.Pi / 60 - math.Pi / 2 val handX = 50 + 40 * math.cos(angle) val handY = 50 + 40 * math.sin(angle) tag(\u0026#34;svg\u0026#34;)(attributes(\u0026#34;viewBox\u0026#34; -\u0026gt; \u0026#34;0, 0, 100, 100\u0026#34;, \u0026#34;width\u0026#34; -\u0026gt; \u0026#34;300px\u0026#34;))( tag(\u0026#34;circle\u0026#34;)(attributes(\u0026#34;cx\u0026#34; -\u0026gt; \u0026#34;50\u0026#34;, \u0026#34;cy\u0026#34; -\u0026gt; \u0026#34;50\u0026#34;, \u0026#34;r\u0026#34; -\u0026gt; \u0026#34;45\u0026#34;, \u0026#34;fill\u0026#34; -\u0026gt; \u0026#34;#0B79CE\u0026#34;))(), tag(\u0026#34;line\u0026#34;)( attributes( \u0026#34;x1\u0026#34; -\u0026gt; \u0026#34;50\u0026#34;, \u0026#34;y1\u0026#34; -\u0026gt; \u0026#34;50\u0026#34;, \u0026#34;x2\u0026#34; -\u0026gt; handX.toString, \u0026#34;y2\u0026#34; -\u0026gt; handY.toString, \u0026#34;stroke\u0026#34; -\u0026gt; \u0026#34;#023963\u0026#34; ) )() ) } def subscriptions(model: Model): Sub[Msg] = Sub.every(1.second, \u0026#34;clock-ticks\u0026#34;).map(Msg.apply) def main(args: Array[String]): Unit = Tyrian.start(document.getElementById(\u0026#34;myapp\u0026#34;), init, update, view, subscriptions) final case class Msg(newTime: js.Date) "
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/information/",
	"title": "General Information",
	"tags": [],
	"description": "",
	"content": "Discussion If you\u0026rsquo;re new to the territory, I highly recommend this thoughtful blog post by Laminar\u0026rsquo;s author, Nikita Gazarov.\nThere is a point in that post where Nikita says the following:\n (..) and having now walked the path myself I finally understood exactly what that reason was: functional reactive programming (FRP) and virtual DOM don\u0026rsquo;t mix!\nVirtual DOM and FRP solve the exact same problem – efficiently keeping the rendered DOM in sync with application state – but they approach it from entirely opposite directions (..)\n \u0026hellip;and that is entirely correct in my opinion. It\u0026rsquo;s an important fork in the road. One direction takes you to FRP and Laminar, the other to Virtual DOM like Tyrian and Elm. Both are equally valid choices with quite subtle trade-offs.\nBroadly the argument for FRP is speed, as updates are minimal and precise. The argument for Virtual DOM is that it\u0026rsquo;s easier to test and reason about.\nHowever, You don\u0026rsquo;t have to look hard to find counter arguments to both positions: Elm is blazing fast, and Laminar has solved the classic diamond problem. \u0026hellip;but that\u0026rsquo;s the general argument.\nIn the end, it\u0026rsquo;s mostly personal preference.\nProvenance, and a note of thanks Tyrian was originally a fork of Scalm by Julien Richard-Foy.\nScalm was the Scala.js library I\u0026rsquo;d been looking for but found too late, and it\u0026rsquo;s great fun! In my opinion it was simply ahead of its time, and alas the original authors and contributors had moved on to pastures new long before it was brought to my attention.\nI decided to fork it and re-release it under a new name, partly because I wanted to take it in my own direction without corrupting the original work, and partly \u0026hellip;because I just wasn\u0026rsquo;t sure how to pronounce Scalm! (I did ask!)\nScalm/Tyrian and Indigo (which I also look after) are kindred spirits, in that they both follow the TEA pattern (The Elm Architecture), which is the only frontend architecture pattern I\u0026rsquo;m interested in these days.\nI hope to use Tyrian to complement Indigo, and so have brought it in under the same organisation.\nTyrian is Scalm with the cobwebs blown off. All it\u0026rsquo;s libraries are up to date, I\u0026rsquo;ve started expanding the API, and it will only ever be released against Scala 3.\nWith huge thanks to the original developers,\nDave, 5th June 2021\n\u0026ldquo;Tyrian\u0026rdquo; Purple  \u0026ldquo;It took tens of thousands of desiccated hypobranchial glands, wrenched from the calcified coils of spiny murex sea snails before being dried and boiled, to colour even a single small swatch of fabric, whose fibres, long after staining, retained the stench of the invertebrate\u0026rsquo;s marine excretions. Unlike other textile colours, whose lustre faded rapidly, Tyrian purple \u0026hellip; only intensified with weathering and wear – a miraculous quality that commanded an exorbitant price, exceeding the pigment\u0026rsquo;s weight in precious metals.\u0026rdquo; ~ BBC\n So it\u0026rsquo;s a purple dye that smells of where it came from and gets richer over time with use. Perfect.\n"
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://purplekingdomgames.github.io/tyrian/",
	"title": "Tyrian",
	"tags": [],
	"description": "",
	"content": "Tyrian Tyrian is an Elm-inspired, purely functional UI library for Scala 3.\nIts purpose is to make building interactive websites in Scala 3 fun! Tyrian allows you to describe web pages and complex interactions in a way that is elegant, easy to read and easy to reason about.\nTyrian is not designed to work alone, the intention is that you will use it alongside a web bundler to look after things like your media assets and stylesheets. (All our examples use Parcel.)\nTyrian 💜's Indigo  Coming in the next release!!\n Tyrian is by the maintainers of Indigo, a Scala 3 game engine. As such, Indigo web games are first class citizens in Tyrian, allowing easy embedding and seamless communication between their respective event/messaging systems.\nWhat should I consider using Tyrian for? Tyrian is designed for building SPAs (Single Page Applications). Web pages with lots of interactive elements.\nOne use case we\u0026rsquo;re particularly excited about is augmenting Indigo games with rich HTML UI elements.\n SSR (Server-side Rendering) is on the road map!\n What should I avoid using Tyrian for? Tyrian is not a great candidate for static websites - like this one! - where the content is there to be read, not interacted / played / engaged with.\n"
}]